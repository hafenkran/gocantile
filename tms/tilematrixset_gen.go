// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package tms

import "encoding/json"
import "fmt"
import "math"
import "reflect"

// Minimum bounding rectangle surrounding a 2D resource in the CRS indicated
// elsewhere
type A2DBoundingBoxJson struct {
	// Crs corresponds to the JSON schema field "crs".
	Crs map[string]interface{} `json:"crs,omitempty" yaml:"crs,omitempty" mapstructure:"crs,omitempty"`

	// LowerLeft corresponds to the JSON schema field "lowerLeft".
	LowerLeft A2DPointJson `json:"lowerLeft" yaml:"lowerLeft" mapstructure:"lowerLeft"`

	// OrderedAxes corresponds to the JSON schema field "orderedAxes".
	OrderedAxes []string `json:"orderedAxes,omitempty" yaml:"orderedAxes,omitempty" mapstructure:"orderedAxes,omitempty"`

	// UpperRight corresponds to the JSON schema field "upperRight".
	UpperRight A2DPointJson `json:"upperRight" yaml:"upperRight" mapstructure:"upperRight"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A2DBoundingBoxJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["lowerLeft"]; raw != nil && !ok {
		return fmt.Errorf("field lowerLeft in A2DBoundingBoxJson: required")
	}
	if _, ok := raw["upperRight"]; raw != nil && !ok {
		return fmt.Errorf("field upperRight in A2DBoundingBoxJson: required")
	}
	type Plain A2DBoundingBoxJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OrderedAxes != nil && len(plain.OrderedAxes) < 2 {
		return fmt.Errorf("field %s length: must be >= %d", "orderedAxes", 2)
	}
	if len(plain.OrderedAxes) > 2 {
		return fmt.Errorf("field %s length: must be <= %d", "orderedAxes", 2)
	}
	*j = A2DBoundingBoxJson(plain)
	return nil
}

// A 2D Point in the CRS indicated elsewhere
type A2DPointJson []float64

// A tile matrix, usually corresponding to a particular zoom level of a
// TileMatrixSet.
type TileMatrixJson struct {
	// Cell size of this tile matrix
	CellSize float64 `json:"cellSize" yaml:"cellSize" mapstructure:"cellSize"`

	// The corner of the tile matrix (_topLeft_ or _bottomLeft_) used as the origin
	// for numbering tile rows and columns. This corner is also a corner of the (0, 0)
	// tile.
	CornerOfOrigin TileMatrixJsonCornerOfOrigin `json:"cornerOfOrigin,omitempty" yaml:"cornerOfOrigin,omitempty" mapstructure:"cornerOfOrigin,omitempty"`

	// Brief narrative description of this tile matrix set, normally available for
	// display to a human
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Identifier selecting one of the scales defined in the TileMatrixSet and
	// representing the scaleDenominator the tile. Implementation of 'identifier'
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Unordered list of one or more commonly used or formalized word(s) or phrase(s)
	// used to describe this dataset
	Keywords []string `json:"keywords,omitempty" yaml:"keywords,omitempty" mapstructure:"keywords,omitempty"`

	// Width of the matrix (number of tiles in width)
	MatrixHeight float64 `json:"matrixHeight" yaml:"matrixHeight" mapstructure:"matrixHeight"`

	// Height of the matrix (number of tiles in height)
	MatrixWidth float64 `json:"matrixWidth" yaml:"matrixWidth" mapstructure:"matrixWidth"`

	// PointOfOrigin corresponds to the JSON schema field "pointOfOrigin".
	PointOfOrigin []float64 `json:"pointOfOrigin" yaml:"pointOfOrigin" mapstructure:"pointOfOrigin"`

	// Scale denominator of this tile matrix
	ScaleDenominator float64 `json:"scaleDenominator" yaml:"scaleDenominator" mapstructure:"scaleDenominator"`

	// Height of each tile of this tile matrix in pixels
	TileHeight float64 `json:"tileHeight" yaml:"tileHeight" mapstructure:"tileHeight"`

	// Width of each tile of this tile matrix in pixels
	TileWidth float64 `json:"tileWidth" yaml:"tileWidth" mapstructure:"tileWidth"`

	// Title of this tile matrix, normally used for display to a human
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Describes the rows that has variable matrix width
	VariableMatrixWidths []VariableMatrixWidthJson `json:"variableMatrixWidths,omitempty" yaml:"variableMatrixWidths,omitempty" mapstructure:"variableMatrixWidths,omitempty"`
}

type TileMatrixJsonCornerOfOrigin string

const TileMatrixJsonCornerOfOriginBottomLeft TileMatrixJsonCornerOfOrigin = "bottomLeft"
const TileMatrixJsonCornerOfOriginTopLeft TileMatrixJsonCornerOfOrigin = "topLeft"

var enumValues_TileMatrixJsonCornerOfOrigin = []interface{}{
	"topLeft",
	"bottomLeft",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TileMatrixJsonCornerOfOrigin) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TileMatrixJsonCornerOfOrigin {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TileMatrixJsonCornerOfOrigin, v)
	}
	*j = TileMatrixJsonCornerOfOrigin(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TileMatrixJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["cellSize"]; raw != nil && !ok {
		return fmt.Errorf("field cellSize in TileMatrixJson: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in TileMatrixJson: required")
	}
	if _, ok := raw["matrixHeight"]; raw != nil && !ok {
		return fmt.Errorf("field matrixHeight in TileMatrixJson: required")
	}
	if _, ok := raw["matrixWidth"]; raw != nil && !ok {
		return fmt.Errorf("field matrixWidth in TileMatrixJson: required")
	}
	if _, ok := raw["pointOfOrigin"]; raw != nil && !ok {
		return fmt.Errorf("field pointOfOrigin in TileMatrixJson: required")
	}
	if _, ok := raw["scaleDenominator"]; raw != nil && !ok {
		return fmt.Errorf("field scaleDenominator in TileMatrixJson: required")
	}
	if _, ok := raw["tileHeight"]; raw != nil && !ok {
		return fmt.Errorf("field tileHeight in TileMatrixJson: required")
	}
	if _, ok := raw["tileWidth"]; raw != nil && !ok {
		return fmt.Errorf("field tileWidth in TileMatrixJson: required")
	}
	type Plain TileMatrixJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["cornerOfOrigin"]; !ok || v == nil {
		plain.CornerOfOrigin = "topLeft"
	}
	{
		remainder := math.Mod(plain.MatrixHeight, 1)
		if !(math.Abs(remainder) < 1e-10 || math.Abs(remainder-1) < 1e-10) {
			return fmt.Errorf("field %s: must be a multiple of %v", "matrixHeight", 1.000000)
		}
	}
	if 1 > plain.MatrixHeight {
		return fmt.Errorf("field %s: must be >= %v", "matrixHeight", 1)
	}
	{
		remainder := math.Mod(plain.MatrixWidth, 1)
		if !(math.Abs(remainder) < 1e-10 || math.Abs(remainder-1) < 1e-10) {
			return fmt.Errorf("field %s: must be a multiple of %v", "matrixWidth", 1.000000)
		}
	}
	if 1 > plain.MatrixWidth {
		return fmt.Errorf("field %s: must be >= %v", "matrixWidth", 1)
	}
	{
		remainder := math.Mod(plain.TileHeight, 1)
		if !(math.Abs(remainder) < 1e-10 || math.Abs(remainder-1) < 1e-10) {
			return fmt.Errorf("field %s: must be a multiple of %v", "tileHeight", 1.000000)
		}
	}
	if 1 > plain.TileHeight {
		return fmt.Errorf("field %s: must be >= %v", "tileHeight", 1)
	}
	{
		remainder := math.Mod(plain.TileWidth, 1)
		if !(math.Abs(remainder) < 1e-10 || math.Abs(remainder-1) < 1e-10) {
			return fmt.Errorf("field %s: must be a multiple of %v", "tileWidth", 1.000000)
		}
	}
	if 1 > plain.TileWidth {
		return fmt.Errorf("field %s: must be >= %v", "tileWidth", 1)
	}
	*j = TileMatrixJson(plain)
	return nil
}

// A definition of a tile matrix set following the Tile Matrix Set standard. For
// tileset metadata, such a description (in `tileMatrixSet` property) is only
// required for offline use, as an alternative to a link with a
// `http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme` relation type.
type TileMatrixSetJson struct {
	// BoundingBox corresponds to the JSON schema field "boundingBox".
	BoundingBox *TileMatrixSetJsonBoundingBox `json:"boundingBox,omitempty" yaml:"boundingBox,omitempty" mapstructure:"boundingBox,omitempty"`

	// Crs corresponds to the JSON schema field "crs".
	Crs interface{} `json:"crs" yaml:"crs" mapstructure:"crs"`

	// Brief narrative description of this tile matrix set, normally available for
	// display to a human
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Tile matrix set identifier. Implementation of 'identifier'
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Unordered list of one or more commonly used or formalized word(s) or phrase(s)
	// used to describe this tile matrix set
	Keywords []string `json:"keywords,omitempty" yaml:"keywords,omitempty" mapstructure:"keywords,omitempty"`

	// OrderedAxes corresponds to the JSON schema field "orderedAxes".
	OrderedAxes []string `json:"orderedAxes,omitempty" yaml:"orderedAxes,omitempty" mapstructure:"orderedAxes,omitempty"`

	// Describes scale levels and its tile matrices
	TileMatrices []TileMatrixJson `json:"tileMatrices" yaml:"tileMatrices" mapstructure:"tileMatrices"`

	// Title of this tile matrix set, normally used for display to a human
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Reference to an official source for this tileMatrixSet
	Uri *string `json:"uri,omitempty" yaml:"uri,omitempty" mapstructure:"uri,omitempty"`

	// Reference to a well-known scale set
	WellKnownScaleSet *string `json:"wellKnownScaleSet,omitempty" yaml:"wellKnownScaleSet,omitempty" mapstructure:"wellKnownScaleSet,omitempty"`
}

// Minimum bounding rectangle surrounding the tile matrix set, in the supported CRS
type TileMatrixSetJsonBoundingBox struct {
	// Crs corresponds to the JSON schema field "crs".
	Crs map[string]interface{} `json:"crs,omitempty" yaml:"crs,omitempty" mapstructure:"crs,omitempty"`

	// LowerLeft corresponds to the JSON schema field "lowerLeft".
	LowerLeft A2DPointJson `json:"lowerLeft" yaml:"lowerLeft" mapstructure:"lowerLeft"`

	// OrderedAxes corresponds to the JSON schema field "orderedAxes".
	OrderedAxes []string `json:"orderedAxes,omitempty" yaml:"orderedAxes,omitempty" mapstructure:"orderedAxes,omitempty"`

	// UpperRight corresponds to the JSON schema field "upperRight".
	UpperRight A2DPointJson `json:"upperRight" yaml:"upperRight" mapstructure:"upperRight"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TileMatrixSetJsonBoundingBox) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["lowerLeft"]; raw != nil && !ok {
		return fmt.Errorf("field lowerLeft in TileMatrixSetJsonBoundingBox: required")
	}
	if _, ok := raw["upperRight"]; raw != nil && !ok {
		return fmt.Errorf("field upperRight in TileMatrixSetJsonBoundingBox: required")
	}
	type Plain TileMatrixSetJsonBoundingBox
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OrderedAxes != nil && len(plain.OrderedAxes) < 2 {
		return fmt.Errorf("field %s length: must be >= %d", "orderedAxes", 2)
	}
	if len(plain.OrderedAxes) > 2 {
		return fmt.Errorf("field %s length: must be <= %d", "orderedAxes", 2)
	}
	*j = TileMatrixSetJsonBoundingBox(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TileMatrixSetJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["crs"]; raw != nil && !ok {
		return fmt.Errorf("field crs in TileMatrixSetJson: required")
	}
	if _, ok := raw["tileMatrices"]; raw != nil && !ok {
		return fmt.Errorf("field tileMatrices in TileMatrixSetJson: required")
	}
	type Plain TileMatrixSetJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.OrderedAxes != nil && len(plain.OrderedAxes) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "orderedAxes", 1)
	}
	*j = TileMatrixSetJson(plain)
	return nil
}

// Variable Matrix Width data structure
type VariableMatrixWidthJson struct {
	// Number of tiles in width that coalesce in a single tile for these rows
	Coalesce float64 `json:"coalesce" yaml:"coalesce" mapstructure:"coalesce"`

	// Last tile row where the coalescence factor applies for this tilematrix
	MaxTileRow float64 `json:"maxTileRow" yaml:"maxTileRow" mapstructure:"maxTileRow"`

	// First tile row where the coalescence factor applies for this tilematrix
	MinTileRow float64 `json:"minTileRow" yaml:"minTileRow" mapstructure:"minTileRow"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VariableMatrixWidthJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["coalesce"]; raw != nil && !ok {
		return fmt.Errorf("field coalesce in VariableMatrixWidthJson: required")
	}
	if _, ok := raw["maxTileRow"]; raw != nil && !ok {
		return fmt.Errorf("field maxTileRow in VariableMatrixWidthJson: required")
	}
	if _, ok := raw["minTileRow"]; raw != nil && !ok {
		return fmt.Errorf("field minTileRow in VariableMatrixWidthJson: required")
	}
	type Plain VariableMatrixWidthJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	{
		remainder := math.Mod(plain.Coalesce, 1)
		if !(math.Abs(remainder) < 1e-10 || math.Abs(remainder-1) < 1e-10) {
			return fmt.Errorf("field %s: must be a multiple of %v", "coalesce", 1.000000)
		}
	}
	if 2 > plain.Coalesce {
		return fmt.Errorf("field %s: must be >= %v", "coalesce", 2)
	}
	{
		remainder := math.Mod(plain.MaxTileRow, 1)
		if !(math.Abs(remainder) < 1e-10 || math.Abs(remainder-1) < 1e-10) {
			return fmt.Errorf("field %s: must be a multiple of %v", "maxTileRow", 1.000000)
		}
	}
	if 0 > plain.MaxTileRow {
		return fmt.Errorf("field %s: must be >= %v", "maxTileRow", 0)
	}
	{
		remainder := math.Mod(plain.MinTileRow, 1)
		if !(math.Abs(remainder) < 1e-10 || math.Abs(remainder-1) < 1e-10) {
			return fmt.Errorf("field %s: must be a multiple of %v", "minTileRow", 1.000000)
		}
	}
	if 0 > plain.MinTileRow {
		return fmt.Errorf("field %s: must be >= %v", "minTileRow", 0)
	}
	*j = VariableMatrixWidthJson(plain)
	return nil
}
